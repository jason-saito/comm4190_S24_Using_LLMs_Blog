<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jason Saito">
<meta name="dcterms.date" content="2024-02-08">
<meta name="description" content="Inspired by a video explaining LLMs and AI, I wanted to test ChatGPT’s limits when it comes to logical reasoning and problem solving.">

<title>My Explorations with LLMs - Testing Logical Reasoning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../interests.html"> 
<span class="menu-text">Interests</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jason-saito"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jason-saito/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Testing Logical Reasoning</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Reasoning</div>
    <div class="quarto-category">ChatGPT</div>
    <div class="quarto-category">Llama 2</div>
  </div>
  </div>

<div>
  <div class="description">
    Inspired by a video explaining LLMs and AI, I wanted to test ChatGPT’s limits when it comes to logical reasoning and problem solving.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jason Saito </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 8, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<h1>
Overview
</h1>
<p>I was curious to see how well ChatGPT and LLama could identify matches in a photo as well logically think through match riddles. This was mainly inspired by a youtube video I watched for class, where many of the leaders of AI questioned whether or not AI can think for itself or if it’s simply a word predictor. I was really curious by this and decided to give it some match riddles that I found on the internet. They were pretty straightforward and I thought it could be a good test to see if ChatGPT and LLama can really think for themselves.</p>
<h1>
How LLMs Respond to Various Prompts
</h1>
<p>Below is the image riddle that I presented ChatGPT with.</p>
<p><img src="matches.png" width="300"></p>
<p>My approach was giving ChatGPT and LLama more and more context to the riddle to see if there was a certain point where it could answer the riddle correctly. My initial prompt was “Given matches in the shapes of 1+11+111=111 in roman numerals. Correct the equation by moving 1 matchstick.”</p>
<h3 class="anchored">
Chat GPT’s Initial Response
</h3>
<p>In Roman numerals, the equation 1+11+111=111 can be rewritten as:</p>
<p>I + XI + CXI = CXI</p>
<p>To correct the equation by moving only one matchstick, we can take one matchstick from the “XI” (which is 11 in Roman numerals) and use it to turn the “I” (which is 1) into a “V” (which is 5 in Roman numerals). This will change the equation to:</p>
<p>V + I + CXI = CXI</p>
<p>In Roman numerals, this equation translates to:</p>
<p>5 + 1 + 111 = 111</p>
<p>This does not make a correct equation as 5 + 1 + 111 is equal to 117, not 111. Instead, we can move a matchstick to make a correct equation. Here’s how:</p>
<p>Take one matchstick from the first “XI” (11 in Roman numerals) and place it on the “+” sign to create an “X” (10 in Roman numerals). This will change the equation to:</p>
<p>I + X + I + CXI = CXI</p>
<p>Now, we have the equation:</p>
<p>1 + 10 + 1 + 111 = 111</p>
<p>Which simplifies to:</p>
<p>123 = 111</p>
<p>This is still incorrect, so let’s try another approach. If we move one matchstick from the “+” sign between the “11” and “111” and place it on the “=” sign to form a “≠” sign (which stands for “not equal to”), we get:</p>
<p>I + XI + CXI ≠ CXI</p>
<p>Now, the equation reads:</p>
<p>1 + 11 + 111 ≠ 111</p>
<p>This statement is true, as 123 is indeed not equal to 111. But this creates a true inequality rather than a true equation. If we want an equation that balances, we need to form different numbers.</p>
<p>Another solution is to move a matchstick from the “plus” sign and turn the “I” from the “111” on the right side of the equation into a “V”. The equation would be:</p>
<p>I + XI + CXI = CVI</p>
<p>Now, we have the equation:</p>
<p>1 + 11 + 111 = 106</p>
<p>Which is a correct equation because 1 + 11 + 111 equals 123, and in Roman numerals, 123 is written as “CXXIII,” not “CVI.” It seems the puzzle as given is unsolvable by moving only one matchstick to create a valid equation in Roman numerals.</p>
<p>If it is indeed a requirement to correct the equation into a valid one by moving only one matchstick, and the equation must remain an equation (not an inequality), then I must admit that I am unable to provide a solution that fits these constraints using standard Roman numerals. It’s possible that there’s a creative interpretation or a particular arrangement of the matchsticks that I haven’t considered. If you could provide more context or additional rules, I may be able to assist further.</p>
<h3 class="anchored">
LLama’s Initial Response
</h3>
<p>The equation in Roman numerals is:</p>
<p>I + X + CXI = CXI</p>
<p>To correct the equation by moving one matchstick, we can move the X from the left-hand side to the right-hand side, like this:</p>
<p>I + CXI + X = CXI</p>
<p>This equation is now balanced, with the Roman numerals adding up to 111 on both sides.</p>
<p>Unfortunately, both answers were wrong, so I decided to give them both more context. I reprompted it with “This is incorrect. Here is a visual representation of the riddle I am providing: https://www.mindyourlogic.com/static/matchstick/Roman_number_1+11+111=111_Matchstick_puzzle.webp,” and got the following answers.</p>
<h3 class="anchored">
ChatGPT’s Respone
</h3>
<p>Thank you for providing the visual representation of the matchstick puzzle. The image shows the equation “I + XI + III = III” in Roman numerals, where “I” represents 1, “XI” represents 11, and “III” represents 3.</p>
<p>To correct the equation by moving only one matchstick, we can change the “XI” (which is 11 in Roman numerals) into “IX” (which is 9 in Roman numerals). Here’s what you do:</p>
<p>Move the matchstick that forms the bottom part of the “X” in “XI” and place it at the end of the “I” on the left side. This changes “XI” to “IX” and the equation now reads:</p>
<p>I + IX + III = III</p>
<p>The Roman numerals now represent:</p>
<p>1 + 9 + 3 = 13</p>
<p>In Roman numerals, thirteen is written as “XIII,” which matches the “III” on the right side of the equation when the “X” from the “IX” we created is added to it.</p>
<p>So the corrected equation is:</p>
<p>I + IX + III = XIII</p>
<p>Which is a valid equation, as 1 + 9 + 3 indeed equals 13.</p>
<h3 class="anchored">
Llama’s Response
</h3>
<p>My apologies for the mistake. Thank you for providing a visual representation of the riddle. Here’s the corrected solution:</p>
<p>To balance the equation, we can move the X from the left-hand side to the right-hand side, like this:</p>
<p>I + 11 + 111 = 111</p>
<p>Now, we can simplify the equation by combining the like terms:</p>
<p>I + 11 + 111 = 111</p>
<p>1 + 11 + 111 = 111</p>
<p>1 + 111 + 111 = 111</p>
<p>1 + 222 = 111</p>
<p>222 = 111</p>
<p>Therefore, the solution to the riddle is:</p>
<p>222 = 111</p>
<p>I hope this clears up any confusion, and please let me know if you have any further questions!</p>
<p>After seeing incorrect responses again, I decided to provide both LLMs with more context and even provided them new approaches. I prompted it with “This is incorrect. Remember that each match can be oriented to be vertical or horizontal, also, the equal signs can be altered as well as they are made of matches.”</p>
<h3 class="anchored">
LLama’s Response
</h3>
<p>Ah, I apologize for my mistake. Here’s another attempt at solving the riddle, taking into account the additional constraints you’ve mentioned:</p>
<p>I + 11 + 111 = 111</p>
<p>We can start by rotating the first matchstick (I) 90 degrees clockwise, so that it becomes vertical. This gives us:</p>
<div class="line-block">1 | + 11 + 111 = 111</div>
<p>Next, we can rotate the second matchstick (11) 90 degrees counterclockwise, so that it becomes horizontal. This gives us:</p>
<div class="line-block">1 | + 11 | 111 = 111</div>
<p>Finally, we can rotate the third matchstick (111) 90 degrees clockwise, so that it becomes vertical. This gives us:</p>
<div class="line-block">1 | + 11 | 111 = 111</div>
<p>Now, we can simplify the equation by combining the like terms:</p>
<div class="line-block">1 | + 11 | 111 = 111</div>
<p>1 + 11 + 111 = 111</p>
<p>1 + 122 = 111</p>
<p>122 = 111</p>
<p>Therefore, the solution to the riddle is:</p>
<p>122 = 111</p>
<p>I hope this solution is correct. Please let me know if you have any further questions or concerns!</p>
<h3 class="anchored">
ChatGPT’s Response
</h3>
<p>I apologize for the misunderstanding. Given the new information and the ability to alter the equals sign, the solution to the matchstick puzzle is as follows:</p>
<p>The original equation represented by matchsticks is “I + XI + III = III,” which translates to “1 + 11 + 3 = 3” in Arabic numerals. This is incorrect.</p>
<p>To correct the equation by moving only one matchstick, you can take the vertical matchstick from the plus sign on the right (which is the middle matchstick of the three that make up the plus sign) and move it to the last “I” of the “III” on the right side of the equals sign. This would turn the “III” into a “V,” which represents the number 5 in Roman numerals.</p>
<p>Now the equation reads:</p>
<p>I + XI + II = V</p>
<p>In Arabic numerals, this is “1 + 11 + 2 = 5,” which is a correct equation.</p>
<p>Eventually I realized that it might not be possible for ChatGPT and LLama to solve the riddle, so I was wondering if they could atleast explain how the riddle works. I prompted it with “This is the correct answer: https://www.mindyourlogic.com/static/matchstick/Answer_Roman_number_1+11+111=111_Matchstick_puzzle.webp. Explain why it is correct”</p>
<p>However, neither could correctly explain the riddle.</p>
<h3 class="anchored">
LLama’s Response
</h3>
<p>The solution to the matchstick puzzle is correct because it satisfies the equation 1+11+111=111, which is a true mathematical statement.</p>
<p>Here’s how the equation is represented in the solution:</p>
<p>1 = I (the first matchstick) 11 = XI (the second matchstick, rotated 90 degrees clockwise) 111 = CXI (the third matchstick, rotated 90 degrees clockwise)</p>
<p>The equation 1+11+111=111 is a simple arithmetic equation, and it is true because:</p>
<p>1 + 11 = 12 12 + 111 = 123</p>
<p>Therefore, the solution to the matchstick puzzle is correct because it accurately represents the equation 1+11+111=111 using matchsticks. The puzzle requires us to think creatively and use the matchsticks to represent the numbers in a way that satisfies the equation, and the solution does just that.</p>
<h3 class="anchored">
ChatGPT’s Response
</h3>
<p>Thank you for providing the solution image. The correct answer to the puzzle shows the matchstick equation altered to form the following:</p>
<p><strong>IX + I + I = III</strong></p>
<p>In Roman numerals, “IX” represents the number 9, “I” represents the number 1, and “III” represents the number 3.</p>
<p>The matchstick that was moved was taken from the “plus” sign and used to turn the “XI” (which is 11) into “IX” (which is 9). This change was accomplished by moving the horizontal matchstick from the plus sign to the left side of the “X” to create the “IX.”</p>
<p>Now, let’s break down the corrected equation:</p>
<ul>
<li>“IX” is 9.</li>
<li>The first “I” is 1.</li>
<li>The second “I” is also 1.</li>
</ul>
<p>Adding these together:</p>
<p>9 (IX) + 1 (I) + 1 (I) = 11 (XI)</p>
<p>However, in the image provided, the equation now appears as “IX + I + I = III,” which seems to imply that 9 + 1 + 1 = 3. This doesn’t add up correctly in standard arithmetic because the sum of 9 + 1 + 1 is actually 11, not 3.</p>
<p>The confusion arises from the representation of the solution. The correct reading should be “IX + I + I = XI,” where the last “I” in “III” is interpreted as part of the equals sign. This is a common style in matchstick puzzles where a matchstick can be used to creatively form different symbols or numbers.</p>
<p>Thus, the correct interpretation of the altered equation with the moved matchstick is:</p>
<p>9 (IX) + 1 (I) + 1 (I) = 11 (XI)</p>
<p>This is a valid equation and is why the provided solution is correct.</p>
<h3 class="anchored">
Can they mirror certain human communicative behaviors?
</h3>
<p>I was really suprised that both ChatGPT and LLama struggled with the riddle as a whole. I feel like an issue could be that neither LLM can identify the matches in the image. I asked both the LLMs how many matches were in the initial images and they both incorrectly counted the number of matches. In terms of their approaches to the were alright, but I feel like since neither accurately solved the riddles, they failed to mirror human communicative behaviors.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/jason-saito\.github\.io\/comm4190_S24_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>